name: Deploy to VPS

on:
    push:
        branches: [main, simple-dev, exp]

jobs:
    deploy:
        runs-on: ubuntu-latest
        steps:
            - name: Checkout
              uses: actions/checkout@v4

            - name: Validate required secrets (password auth)
              env:
                  DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
                  DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
                  DEPLOY_PASSWORD: ${{ secrets.DEPLOY_PASSWORD }}
                  DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
              run: |
                  if [ -z "${DEPLOY_HOST}" ] || [ -z "${DEPLOY_USER}" ] || [ -z "${DEPLOY_PASSWORD}" ] || [ -z "${DEPLOY_PATH}" ]; then
                    echo "One or more required secrets are missing: DEPLOY_HOST, DEPLOY_USER, DEPLOY_PASSWORD, DEPLOY_PATH"
                    exit 1
                  fi

            - name: Install sshpass for password-based SSH
              run: sudo apt-get update && sudo apt-get install -y sshpass

            - name: Preflight SSH check (password)
              env:
                  DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
                  DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
                  DEPLOY_PASSWORD: ${{ secrets.DEPLOY_PASSWORD }}
                  DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
              run: |
                  SSH_OPTS=""
                  if [ -n "${DEPLOY_PORT}" ]; then
                    SSH_OPTS="-p ${DEPLOY_PORT}"
                  fi
                  if [ -n "${DEPLOY_PORT}" ]; then
                    echo "Testing SSH connection to ${DEPLOY_USER}@${DEPLOY_HOST} on port ${DEPLOY_PORT}"
                  else
                    echo "Testing SSH connection to ${DEPLOY_USER}@${DEPLOY_HOST} on default port"
                  fi
                  sshpass -p "${DEPLOY_PASSWORD}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 $SSH_OPTS "${DEPLOY_USER}@${DEPLOY_HOST}" "echo connected" || (echo "SSH preflight failed: check DEPLOY_HOST/DEPLOY_USER and DEPLOY_PASSWORD, and that PasswordAuthentication is enabled on the VPS" && exit 1)

            - name: Setup Node.js (for frontend build)
              uses: actions/setup-node@v4
              with:
                  node-version: "20"

            - name: Cache frontend node modules
              uses: actions/cache@v4
              with:
                  path: frontend/node_modules
                  key: ${{ runner.os }}-node-${{ hashFiles('frontend/yarn.lock', 'frontend/package.json') }}
                  restore-keys: |
                      ${{ runner.os }}-node-

            - name: Install frontend deps
              working-directory: frontend
              run: yarn install --frozen-lockfile

            - name: Build frontend
              working-directory: frontend
              run: yarn build

            - name: Create tarball
              run: |
                  # Exclude large/runtime artifacts (Solr release folder, venv, node_modules, data files)
                  tar -czf /tmp/repo_deploy.tar.gz \
                    --exclude='.git' \
                    --exclude='.venv' \
                    --exclude='data' \
                    --exclude='frontend/node_modules' \
                    --exclude='solr-*' \
                    --exclude='frontend/.turbo' \
                    .
                  echo "Created /tmp/repo_deploy.tar.gz (size: $(ls -lh /tmp/repo_deploy.tar.gz | awk '{print $5}'))"

            - name: Copy tarball to VPS (password auth)
              env:
                  DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
                  DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
                  DEPLOY_PASSWORD: ${{ secrets.DEPLOY_PASSWORD }}
                  DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
              run: |
                  set -euo pipefail
                  if [ -n "${DEPLOY_PORT}" ]; then
                    sshpass -p "${DEPLOY_PASSWORD}" scp -o StrictHostKeyChecking=no -o ConnectTimeout=10 -P "${DEPLOY_PORT}" /tmp/repo_deploy.tar.gz "${DEPLOY_USER}@${DEPLOY_HOST}:/tmp/repo_deploy.tar.gz"
                  else
                    sshpass -p "${DEPLOY_PASSWORD}" scp -o StrictHostKeyChecking=no -o ConnectTimeout=10 /tmp/repo_deploy.tar.gz "${DEPLOY_USER}@${DEPLOY_HOST}:/tmp/repo_deploy.tar.gz"
                  fi

            - name: Remote extract, install and restart
              env:
                  DEPLOY_HOST: ${{ secrets.DEPLOY_HOST }}
                  DEPLOY_USER: ${{ secrets.DEPLOY_USER }}
                  DEPLOY_PASSWORD: ${{ secrets.DEPLOY_PASSWORD }}
                  DEPLOY_PATH: ${{ secrets.DEPLOY_PATH }}
                  DEPLOY_PORT: ${{ secrets.DEPLOY_PORT }}
              run: |
                  set -euo pipefail
                  # compute optional port argument (empty if not provided)
                  PORT_ARG=""
                  if [ -n "${DEPLOY_PORT}" ]; then
                    PORT_ARG="-p ${DEPLOY_PORT}"
                  fi

                  # single heredoc invocation (avoids nested heredoc parsing issues)
                  # pass DEPLOY_PATH and DEPLOY_USER into the remote shell so the heredoc
                  # can rely on them without needing local variable expansion inside the
                  # single-quoted heredoc body.
                  sshpass -p "${DEPLOY_PASSWORD}" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=10 $PORT_ARG "${DEPLOY_USER}@${DEPLOY_HOST}" "DEPLOY_PATH='${DEPLOY_PATH}' DEPLOY_USER='${DEPLOY_USER}' bash -s" <<'REMOTE'
                    set -euo pipefail
                    echo "Deploying to $DEPLOY_PATH"

                    # Ensure deployment directory exists and is owned by the deploy user
                    sudo mkdir -p "$DEPLOY_PATH"
                    sudo chown -R "${DEPLOY_USER}:${DEPLOY_USER}" "$DEPLOY_PATH"

                    # Extract tarball as the deploy user to avoid root-owned files
                    sudo -u "${DEPLOY_USER}" tar -xzf /tmp/repo_deploy.tar.gz -C "$DEPLOY_PATH"
                    sudo rm -f /tmp/repo_deploy.tar.gz

                    # Setup Solr (if present) â€” keep as sudo since it may require root
                    echo "========================================="
                    echo "Installing Docker + docker compose and running docker-compose.yml..."
                    echo "========================================="

                    # Install Docker if not already installed
                    if ! command -v docker >/dev/null 2>&1; then
                      echo "Installing Docker..."
                      sudo apt-get update
                      sudo apt-get install -y docker.io
                      sudo systemctl enable --now docker
                    else
                      echo "Docker already installed"
                    fi

                    # Install docker compose plugin if missing (use Docker's repo to ensure package is available)
                    if ! docker compose version >/dev/null 2>&1; then
                      echo "Installing docker compose plugin via Docker APT repo..."
                      sudo apt-get update
                      sudo apt-get install -y ca-certificates curl gnupg lsb-release
                      curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /usr/share/keyrings/docker-archive-keyring.gpg
                      echo "deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/docker-archive-keyring.gpg] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable" | sudo tee /etc/apt/sources.list.d/docker.list > /dev/null
                      sudo apt-get update
                      # Install non-interactively to avoid debconf TTY errors
                      sudo DEBIAN_FRONTEND=noninteractive apt-get install -y docker-compose-plugin
                    else
                      echo "docker compose plugin available"
                    fi

                    # Ensure deployment dir has the compose file (tarball extracted earlier)
                    if [ -f "$DEPLOY_PATH/docker-compose.yml" ]; then
                      echo "Found docker-compose.yml in deployment path"
                    else
                      echo "docker-compose.yml not found in $DEPLOY_PATH; falling back to running solr container"
                      sudo docker pull solr:latest
                      sudo docker run -d --name solr -p 8983:8983 -e SOLR_MODULES=clustering -v /var/solr:/var/solr solr:latest solr-precreate movies
                    fi

                    # Use docker compose to bring up services defined in the repo
                    if [ -f "$DEPLOY_PATH/docker-compose.yml" ]; then
                      sudo chown -R "${DEPLOY_USER}:${DEPLOY_USER}" "$DEPLOY_PATH"
                      cd "$DEPLOY_PATH"

                      # Recreate services from the ground up on every deploy.
                      # This will stop and remove existing containers and start fresh.
                      echo "Recreating services from scratch (docker compose down + up)"
                      cd "$DEPLOY_PATH"
                      # Pull latest images but don't fail the deploy if pull has issues
                      sudo docker compose pull || true
                      # Stop and remove containers and named volumes so the fresh container will read repo-mounted config.
                      sudo docker compose down -v --remove-orphans || true
                      # Start freshly; force rebuild and recreate to ensure config from repo is used.
                      sudo docker compose up -d --force-recreate --build

                      # Wait for Solr to be ready (up to 60 seconds)
                      for j in {1..60}; do
                        if curl -s "http://localhost:8983/solr/admin/cores?action=STATUS" > /dev/null 2>&1; then
                          echo "Solr is ready"
                          break
                        fi
                        if [ $j -eq 60 ]; then
                          echo "ERROR: Solr from docker compose is not responding after 60 seconds"
                          exit 1
                        fi
                        sleep 1
                      done

                      # Determine the running Solr container to target for single-file updates.
                      SOLR_CONTAINER=""
                      if sudo docker ps --filter "name=heritage-solr-1" --format '{{.Names}}' | grep -q .; then
                        SOLR_CONTAINER="heritage-solr-1"
                      else
                        SOLR_CONTAINER=$(sudo docker ps --filter "ancestor=solr:latest" --format '{{.Names}}' | head -n1 || true)
                      fi

                      # If a repo solrconfig.xml exists at the repo root, copy only that file
                      # into the running Solr container so we don't replace the full conf dir.
                      if [ -n "$SOLR_CONTAINER" ] && [ -f "$DEPLOY_PATH/solrconfig.xml" ]; then
                        echo "Applying repo solrconfig.xml into running Solr container: $SOLR_CONTAINER"
                        sudo docker cp "$DEPLOY_PATH/solrconfig.xml" "$SOLR_CONTAINER":/var/solr/data/movies/conf/solrconfig.xml || true
                        sudo docker exec "$SOLR_CONTAINER" bash -lc "chown solr:solr /var/solr/data/movies/conf/solrconfig.xml" || true
                        # Reload core to pick up changes
                        curl -s "http://localhost:8983/solr/admin/cores?action=RELOAD&core=movies" || true
                      else
                        if [ -f "$DEPLOY_PATH/solrconfig.xml" ]; then
                          echo "Warning: could not find a running Solr container to apply solrconfig.xml"
                        fi
                      fi
                    fi

                    # Install Python dependencies inside a venv as the deploy user
                    echo "========================================="
                    echo "Installing Python dependencies..."
                    echo "========================================="
                    sudo -u "${DEPLOY_USER}" bash -lc "cd '$DEPLOY_PATH' && python3 -m venv .venv || true"
                    sudo -u "${DEPLOY_USER}" bash -lc "cd '$DEPLOY_PATH' && . .venv/bin/activate && pip install --upgrade pip && pip install -r requirements.txt"

                    # Index data into Solr (run with venv as deploy user)
                    echo "========================================="
                    echo "Indexing data into Solr..."
                    echo "========================================="
                    # Wait for Solr to be ready (up to 30 seconds)
                    for i in {1..30}; do
                      if curl -s "http://localhost:8983/solr/admin/cores?action=STATUS" > /dev/null 2>&1; then
                        echo "Solr is ready"
                        break
                      fi
                      if [ $i -eq 30 ]; then
                        echo "ERROR: Solr is not responding after 30 seconds"
                        exit 1
                      fi
                      sleep 1
                    done

                    # Run indexing inside the venv as deploy user
                    sudo -u "${DEPLOY_USER}" bash -lc "cd '$DEPLOY_PATH' && . .venv/bin/activate && python index_data.py" || {
                      echo "ERROR: Data indexing failed"
                      exit 1
                    }

                    # Verify indexing
                    DOC_COUNT=$(curl -s "http://localhost:8983/solr/movies/select?q=*:*&rows=0" | grep -oP '"numFound":\K\d+' || echo "0")
                    echo "Indexed documents: $DOC_COUNT"
                    if [ "$DOC_COUNT" -eq 0 ]; then
                      echo "WARNING: No documents were indexed!"
                    fi

                    # Restart services (keep sudo)
                    sudo systemctl restart heritage
                    sudo systemctl start heritage-indexer.service || true
                    echo "Remote deploy finished"
                  REMOTE

            - name: Cleanup local tarball
              run: rm -f /tmp/repo_deploy.tar.gz
